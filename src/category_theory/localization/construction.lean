/-
Copyright (c) 2022 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/

import category_theory.arrow_class
import category_theory.category.Quiv

/-!

# Construction of the localized category

This file constructs the localized category, obtained by formally inverting
a class of maps `W : arrow_class C` in a category `C`.

We first construct a quiver `loc_quiver W` whose objects are the same as those
of `C` and whose maps are the maps in `C` and placeholders for the formal
inverses of the maps in `W`.

The localizated category `localization W` is obtained by taking the quotient
of the path category of `loc_quiver W` by the congruence generated by four
types of relations.

The obvious functor `Q W : C ‚•§ localization W` satisfies the universal property
of the localization. Indeed, if `G : C ‚•§ D` sends morphisms in `W` to isomorphisms
in `D` (i.e. we have `hG : W.is_inverted_by G`), then there exists a unique functor
`G' : localization W ‚•§ D` such that `Q W ‚â´ G' = G`. This `G'` is `lift G hG`.
The expected property of `lift G hG` if expressed by the lemma `fac` and the
uniqueness is expressed by `fac`.

## References

* [P. Gabriel, M. Zisman, *Calculus of fractions and homotopy theory*][gabriel-zisman-1967]

-/

noncomputable theory

open category_theory.category

namespace category_theory

namespace arrow_class

variables {C : Type*} [category C] (W : arrow_class C)
variables {D : Type*} [category D]

namespace localization

/-- If `W : arrow_class C`, `loc_quiver W` is a quiver with the same objects as `C`, and
whose morphisms are those in `C` and placeholders for formal inverses of the morphisms
in `W`. -/
@[nolint has_inhabited_instance]
structure loc_quiver (W : arrow_class C) := (obj : C)

instance : quiver (loc_quiver W) :=
{ hom := Œª A B, (A.obj ‚ü∂ B.obj) ‚äï { f : B.obj ‚ü∂ A.obj // arrow.mk f ‚àà W} }

/-- The object in the path category of `loc_quiver W` attached to an object in
the category `C` such that `W : arrow_class C` -/
def Œπ_paths (X : C) : paths (loc_quiver W) := ‚ü®X‚ü©

/-- The morphism in the path category associated to a morphism in the original category. -/
@[simp]
def œà‚ÇÅ' {X Y : paths (loc_quiver W)} (f : X.obj ‚ü∂ Y.obj) : X ‚ü∂ Y := paths.of.map (sum.inl f)

/-- The morphism in the path category associated to a morphism in the original category. -/
@[simp]
def œà‚ÇÅ {X Y : C} (f : X ‚ü∂ Y) : Œπ_paths W X ‚ü∂ Œπ_paths W Y := paths.of.map (sum.inl f)

/-- The morphism in the path category corresponding to a formal inverse. -/
@[simp]
def œà‚ÇÇ' {X Y : paths (loc_quiver W)} (w : X.obj ‚ü∂ Y.obj) (hw : arrow.mk w ‚àà W) : Y ‚ü∂ X :=
paths.of.map (sum.inr ‚ü®w, hw‚ü©)

/-- The morphism in the path category corresponding to a formal inverse. -/
@[simp]
def œà‚ÇÇ {X Y : C} (w : X ‚ü∂ Y) (hw : arrow.mk w ‚àà W) : Œπ_paths W Y ‚ü∂ Œπ_paths W X := œà‚ÇÇ' W w hw

/-- The relations by which we take the quotient in order to get the localized category. -/
inductive relations ‚¶ÉX Y : (paths (loc_quiver W))‚¶Ñ : (X ‚ü∂ Y) ‚Üí (X ‚ü∂ Y) ‚Üí Prop
| id (œÜ : X ‚ü∂ Y) :
  relations (œà‚ÇÅ' W (ùüô X.obj) ‚â´ œÜ) œÜ
| comp {Z : paths (loc_quiver W)} (f : X.obj ‚ü∂ Z.obj) (g : Z.obj ‚ü∂ Y.obj) :
  relations (œà‚ÇÅ' W (f ‚â´ g)) (œà‚ÇÅ' W f ‚â´ œà‚ÇÅ' W g)
| Winv‚ÇÅ {Z : paths (loc_quiver W)} (w : X.obj ‚ü∂ Z.obj) (hw : arrow.mk w ‚àà W) (œÜ : X ‚ü∂ Y) :
  relations (œà‚ÇÅ' W w ‚â´ œà‚ÇÇ' W w hw ‚â´ œÜ) œÜ
| Winv‚ÇÇ {Z : paths (loc_quiver W)} (w : Z.obj ‚ü∂ Y.obj) (hw : arrow.mk w ‚àà W) (œÜ : X ‚ü∂ Y) :
  relations (œÜ ‚â´ œà‚ÇÇ' W w hw ‚â´ œà‚ÇÅ' W w) œÜ

end localization

/-- The localized category obtained by formally inverting the morphisms in `W : arrow_class C` -/
@[derive category, nolint has_inhabited_instance]
def localization := category_theory.quotient (localization.relations W)

namespace localization

/-- The obvious functor `C ‚•§ localization W` -/
def Q : C ‚•§ W.localization :=
{ obj := Œª X, (quotient.functor _).obj (paths.of.obj ‚ü®X‚ü©),
  map := Œª X Y f, (quotient.functor _).map (œà‚ÇÅ W f),
  map_id' := Œª X, by convert quotient.sound _ (@relations.id _ _ W (paths.of.obj ‚ü®X‚ü©) _ (ùüô _)),
  map_comp' := Œª X Z Y f g, quotient.sound _
    (@relations.comp _ _ W (paths.of.obj ‚ü®X‚ü©) (paths.of.obj ‚ü®Y‚ü©) (paths.of.obj ‚ü®Z‚ü©) f g), }

/-- The isomorphism in `localization W` associated to a morphism `w` in W -/
def Wiso {X Y : C} (w : X ‚ü∂ Y) (hw : arrow.mk w ‚àà W) : iso ((Q W).obj X) ((Q W).obj Y) :=
{ hom := (Q W).map w,
  inv := (quotient.functor _).map (paths.of.map (sum.inr ‚ü®w, hw‚ü©)),
  hom_inv_id' := quotient.sound _ (@relations.Winv‚ÇÅ _ _ _
    (paths.of.obj ‚ü®X‚ü©) _ (paths.of.obj ‚ü®Y‚ü©) w hw (ùüô _)),
  inv_hom_id' := quotient.sound _ (@relations.Winv‚ÇÇ _ _ _
    (paths.of.obj ‚ü®Y‚ü©) (paths.of.obj ‚ü®Y‚ü©) (paths.of.obj ‚ü®X‚ü©) w hw (ùüô _)), }

/-- The isomorphism in `localization W` associated to a morphism `w : W` -/
def Wiso' (w : W) : iso ((Q W).obj w.1.left) ((Q W).obj w.1.right) :=
Wiso W w.1.hom (by { rw arrow.mk_eq w.1, exact w.2, })

lemma W_is_inverted_by_Q : W.is_inverted_by (Q W) := Œª w, is_iso.of_iso (Wiso' W w)

variables {W}

variables (G : C ‚•§ D) (hG : W.is_inverted_by G)

include G hG

/-- The lifting of a functor to the path category of `loc_quiver W` -/
@[simps]
def lift_to_path_category : paths (loc_quiver W) ‚•§ D :=
Quiv.lift
{ obj := Œª X, G.obj X.obj,
  map := Œª X Y, begin
    rintro (f|‚ü®g, hg‚ü©),
    { exact G.map f, },
    { haveI : is_iso (G.map g) := hG ‚ü®arrow.mk g, hg‚ü©,
      exact inv (G.map g), },
  end, }

/-- The lifting of a functor `C ‚•§ D` inverting `W` as a functor `localization W ‚•§ D` -/
def lift : localization W ‚•§ D :=
quotient.lift (relations W) (lift_to_path_category G hG)
begin
  rintro ‚ü®X‚ü© ‚ü®Y‚ü© f‚ÇÅ f‚ÇÇ r,
  rcases r with (_|‚ü®‚ü®Z‚ü©, f, g‚ü©|‚ü®‚ü®Z‚ü©, w, hw‚ü©|‚ü®‚ü®Z‚ü©, w, hw‚ü©),
  tidy,
end

@[simp]
lemma fac : Q W ‚ãô lift G hG = G :=
begin
  apply functor.ext,
  { intros X Y f,
    simp only [functor.comp_map, eq_to_hom_refl, comp_id, id_comp],
    dsimp [lift, lift_to_path_category, Q],
    rw id_comp, },
  { intro X,
    refl, }
end

omit G hG

lemma uniq (G‚ÇÅ G‚ÇÇ : localization W ‚•§ D) (h : Q W ‚ãô G‚ÇÅ = Q W ‚ãô G‚ÇÇ) :
  G‚ÇÅ = G‚ÇÇ :=
begin
  suffices h' : quotient.functor _ ‚ãô G‚ÇÅ = quotient.functor _ ‚ãô G‚ÇÇ,
  { apply functor.ext,
    { rintros ‚ü®‚ü®X‚ü©‚ü© ‚ü®‚ü®Y‚ü©‚ü© ‚ü®f‚ü©,
      convert functor.congr_hom h' f, },
    { rintro ‚ü®‚ü®X‚ü©‚ü©,
      convert functor.congr_obj h X, }, },
  { apply paths.ext_functor,
    { rintro ‚ü®X‚ü© ‚ü®Y‚ü© f,
      cases f,
      { convert functor.congr_hom h f, },
      { rcases f with ‚ü®w, hw‚ü©,
        have hw : (Q W).map w = (Wiso W w hw).hom := rfl,
        have hw' := functor.congr_hom h w,
        simp only [functor.comp_map, hw] at hw',
        refine functor.congr_inv_of_congr_hom _ _ _ _ _ hw',
        { convert functor.congr_obj h Y, },
        { convert functor.congr_obj h X, }, }, },
    { ext X,
      cases X,
      apply functor.congr_obj h, }, }
end

end localization

end arrow_class

end category_theory
