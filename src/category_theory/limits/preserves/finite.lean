/-
Copyright (c) 2021 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import category_theory.limits.preserves.basic
import category_theory.fin_category

/-!
# Preservation of finite (co)limits.

These functors are also known as left exact (flat) or right exact functors when the categories
involved are abelian, or more generally, finitely (co)complete.

## Related results
* `category_theory.limits.preserves_finite_limits_of_preserves_equalizers_and_finite_products` :
  see `category_theory/limits/constructions/limits_of_products_and_equalizers.lean`. Also provides
  the dual version.
* `category_theory.limits.preserves_finite_limits_iff_flat` :
  see `category_theory/flat_functors.lean`.

-/

open category_theory

namespace category_theory.limits

-- declare the `v`'s first; see `category_theory.category` for an explanation
universes w w‚ÇÇ v‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÅ u‚ÇÇ u‚ÇÉ

variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C]
variables {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D]
variables {E : Type u‚ÇÉ} [category.{v‚ÇÉ} E]

variables {J : Type w} [small_category J] {K : J ‚•§ C}

/--
A functor is said to preserve finite limits of size `w`, if it preserves all limits of shape `J`,
where `J : Type w` is a finite category.
-/
class preserves_finite_limits_of_size (F : C ‚•§ D) :=
(preserves_finite_limits : Œ† (J : Type w) [small_category J] [fin_category J],
  preserves_limits_of_shape J F . tactic.apply_instance)

/-- Preserving finite limits means preserving finite limits of size `0`. -/
abbreviation preserves_finite_limits (F : C ‚•§ D) := preserves_finite_limits_of_size.{0} F

attribute [instance] preserves_finite_limits_of_size.preserves_finite_limits

/--
`preserves_finite_limits_of_size_shrink.{w} F` tries to obtain
`preserves_finite_limits_of_size.{w} F` from some other `preserves_finite_limits_of_size F`.
-/
def preserves_finite_limits_of_size_shrink (F : C ‚•§ D)
  [hpres : preserves_finite_limits_of_size.{(max w w‚ÇÇ)} F] :
  preserves_finite_limits_of_size.{w} F :=
‚ü®Œª (J : Type w) hJ fJ, by {
    resetI,
    letI : small_category (ulift_hom.{w‚ÇÇ} (ulift.{w‚ÇÇ} J)),
    { exact (@ulift_hom.category (ulift.{w‚ÇÇ w} J) (@category_theory.ulift_category J _)) },
    haveI := preserves_finite_limits_of_size.preserves_finite_limits
      (ulift_hom.{w‚ÇÇ (max w w‚ÇÇ)} (ulift.{w‚ÇÇ w} J)),
    apply preserves_limits_of_shape_of_equiv (ulift_hom_ulift_category.equiv.{w‚ÇÇ w‚ÇÇ} J).symm F,
    rotate, rotate, rotate, rotate, rotate, exact hpres,
  }‚ü©

def preserves_finite_limits_of_preserve_finite_limits_of_size
  (F : C ‚•§ D) [preserves_finite_limits_of_size.{w} F] : preserves_finite_limits F :=
preserves_finite_limits_of_size_shrink F

@[priority 100]
instance preserves_limits.preserves_finite_limits (F : C ‚•§ D) [preserves_limits_of_size.{w w} F] :
  preserves_finite_limits_of_size.{w} F := {}

instance id_preserves_finite_limits :
  preserves_finite_limits_of_size (ùü≠ C) := {}

/-- The composition of two left exact functors is left exact. -/
def comp_preserves_finite_limits (F : C ‚•§ D) (G : D ‚•§ E)
  [preserves_finite_limits_of_size.{w} F] [preserves_finite_limits_of_size.{w} G] :
  preserves_finite_limits_of_size.{w} (F ‚ãô G) :=
‚ü®Œª _ _ _, by { resetI, apply_instance }‚ü©

/--
A functor is said to preserve finite colimits of size `w`, if it preserves all colimits of 
shape `J`, where `J : Type w` is a finite category.
-/
class preserves_finite_colimits_of_size (F : C ‚•§ D) :=
(preserves_finite_colimits : Œ† (J : Type w) [small_category J] [fin_category J],
  preserves_colimits_of_shape J F . tactic.apply_instance)

  /-- Preserving finite colimits means preserving finite colimits of size `0`. -/
abbreviation preserves_finite_colimits (F : C ‚•§ D) := preserves_finite_colimits_of_size.{0} F

attribute [instance] preserves_finite_colimits_of_size.preserves_finite_colimits

/--
`preserves_finite_colimits_of_size_shrink.{w} F` tries to obtain
`preserves_finite_colimits_of_size.{w} F` from some other `preserves_finite_colimits_of_size F`.
-/
def preserves_finite_colimits_of_size_shrink (F : C ‚•§ D)
  [hpres : preserves_finite_colimits_of_size.{(max w w‚ÇÇ)} F] :
  preserves_finite_colimits_of_size.{w} F :=
‚ü®Œª (J : Type w) hJ fJ, by {
    resetI,
    letI : small_category (ulift_hom.{w‚ÇÇ} (ulift.{w‚ÇÇ} J)),
    { exact (@ulift_hom.category (ulift.{w‚ÇÇ w} J) (@category_theory.ulift_category J _)) },
    haveI := preserves_finite_colimits_of_size.preserves_finite_colimits
      (ulift_hom.{w‚ÇÇ (max w w‚ÇÇ)} (ulift.{w‚ÇÇ w} J)),
    apply preserves_colimits_of_shape_of_equiv (ulift_hom_ulift_category.equiv.{w‚ÇÇ w‚ÇÇ} J).symm F,
    rotate, rotate, rotate, rotate, rotate, exact hpres,
  }‚ü©

set_option pp.universes true
def preserves_finite_colimits_of_preserve_finite_colimits_of_size
  (F : C ‚•§ D) [preserves_finite_colimits_of_size.{w} F] : preserves_finite_colimits F :=
preserves_finite_colimits_of_size_shrink F

@[priority 100]
instance preserves_colimits.preserves_finite_colimits (F : C ‚•§ D)
  [preserves_colimits_of_size.{w w} F] : preserves_finite_colimits_of_size.{w} F := {}

instance id_preserves_finite_colimits :
  preserves_finite_colimits_of_size (ùü≠ C) := {}

/-- The composition of two right exact functors is right exact. -/
def comp_preserves_finite_colimits (F : C ‚•§ D) (G : D ‚•§ E)
  [preserves_finite_colimits_of_size.{w} F] [preserves_finite_colimits_of_size.{w} G] :
  preserves_finite_colimits_of_size.{w} (F ‚ãô G) :=
‚ü®Œª _ _ _, by { resetI, apply_instance }‚ü©

end category_theory.limits
