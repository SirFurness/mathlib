import analysis.normed_space.basic

open fintype

def ham {Œπ : Type*} [fintype Œπ] (Œ≤ : Œπ ‚Üí Type*) : Type* := Œ† i, Œ≤ i

instance {Œπ : Type*} [fintype Œπ] (Œ≤ : Œπ ‚Üí Type*) [Œ† i, inhabited (Œ≤ i)] : inhabited (ham Œ≤) :=
‚ü®Œª i, default‚ü©

local notation `ùìó[` K`,` n`]` := ham (Œª _ : fin n, K)

namespace hamming
variables {Œ± Œπ : Type*} [fintype Œπ] {Œ≤ : Œπ ‚Üí Type*}

@[pattern] def of_ham : ham Œ≤ ‚âÉ Œ† i, Œ≤ i := equiv.refl _
@[pattern] def to_ham : (Œ† i, Œ≤ i) ‚âÉ ham Œ≤ := equiv.refl _

@[simp] lemma to_ham_symm_eq                : (@to_ham _ _ Œ≤).symm = of_ham := rfl
@[simp] lemma of_ham_symm_eq                : (@of_ham _ _ Œ≤).symm = to_ham := rfl
@[simp] lemma to_ham_of_ham (x : ham Œ≤)     : to_ham (of_ham x) = x := rfl
@[simp] lemma of_ham_to_ham (x : Œ† i, Œ≤ i)  : of_ham (to_ham x) = x := rfl
@[simp] lemma to_ham_inj {x y : Œ† i, Œ≤ i}   : to_ham x = to_ham y ‚Üî x = y := iff.rfl
@[simp] lemma of_ham_inj {x y : ham Œ≤}      : of_ham x = of_ham y ‚Üî x = y := iff.rfl

instance [Œ† i, has_zero (Œ≤ i)] : has_zero (ham Œ≤) := pi.has_zero
instance [Œ† i, has_sub (Œ≤ i)] : has_sub (ham Œ≤) := pi.has_sub
instance [Œ† i, has_scalar Œ± (Œ≤ i)] : has_scalar Œ± (ham Œ≤) := pi.has_scalar
instance [has_zero Œ±] [Œ† i, has_zero (Œ≤ i)] [Œ† i, smul_with_zero Œ± (Œ≤ i)] :
smul_with_zero Œ± (ham Œ≤) := pi.smul_with_zero _

instance [monoid Œ±] [Œ† i, add_monoid (Œ≤ i)] [Œ† i, distrib_mul_action Œ± (Œ≤ i)] :
distrib_mul_action Œ± (ham Œ≤) := pi.distrib_mul_action _

-- This "should" be `add_comm_monoid`. But if one does this,
-- you can get what I think are diamond problems to do with semi_normed_group...
-- This would be solved if we had normed_monoid, maybe?
-- It's possible that it is better to extend things in another way?

instance [semiring Œ±] [Œ† i, add_comm_group (Œ≤ i)] [Œ† i, module Œ± (Œ≤ i)] :
module Œ± (ham Œ≤) := pi.module _ _ _

section decidable_eq

variables {Œ≤} [Œ† i, decidable_eq (Œ≤ i)]

def ham_dist (x y : ham Œ≤) := card {i // x i ‚â† y i}

lemma ham_dist_smul_le [Œ† i, has_scalar Œ± (Œ≤ i)] (k : Œ±) (x y : ham Œ≤) :
ham_dist (k ‚Ä¢ x) (k ‚Ä¢ y) ‚â§ ham_dist x y :=
card_subtype_mono _ _ (Œª i h H, h (by rw [pi.smul_apply, pi.smul_apply, H]))

lemma ham_dist_smul [Œ† i, has_scalar Œ± (Œ≤ i)] {k : Œ±} (hk : ‚àÄ i, is_smul_regular (Œ≤ i) k)
(x y : ham Œ≤) : ham_dist x y = ham_dist (k ‚Ä¢ x) (k ‚Ä¢ y) :=
le_antisymm (card_subtype_mono _ _ (Œª _ h H, h (hk _ H))) (ham_dist_smul_le _ _ _)

lemma ham_dist_eq (x y : ham Œ≤) : ham_dist x y = card {i // x i ‚â† y i} := rfl

lemma ham_dist_comm (x y : ham Œ≤) : ham_dist x y = ham_dist y x :=
by simp_rw [ham_dist_eq, ne_comm]

lemma ham_dist_triangle (x y z : ham Œ≤) : ham_dist x z ‚â§ ham_dist x y + ham_dist y z :=
begin
  simp_rw ham_dist_eq, refine le_trans (card_subtype_mono _ _ (Œª _ h, _)) (card_subtype_or _ _), by_contra' H, exact h (eq.trans H.1 H.2)
end

lemma ham_dist_eq_zero (x y : ham Œ≤) : ham_dist x y = 0 ‚Üî x = y :=
begin
  rw [function.funext_iff, ham_dist_eq, card_eq_zero_iff],
  exact ‚ü® Œª h i, imp_of_not_imp_not _ _ (Œª H, h.elim' ‚ü®i, H‚ü©) h,
          Œª h, subtype.is_empty_of_false (Œª i H, H (h _))‚ü©
end

lemma ham_dist_self (x : ham Œ≤) : ham_dist x x = 0 := (ham_dist_eq_zero _ _).mpr rfl

lemma eq_of_ham_dist_eq_zero (x y : ham Œ≤) : ham_dist x y = 0 ‚Üí x = y := (ham_dist_eq_zero _ _).mp

lemma ham_dist_ne_zero (x y : ham Œ≤) : ham_dist x y ‚â† 0 ‚Üî x ‚â† y :=
not_iff_not.mpr (ham_dist_eq_zero _ _)

lemma ham_dist_pos (x y : ham Œ≤) : 0 < ham_dist x y ‚Üî x ‚â† y :=
by rw [‚Üêham_dist_ne_zero, iff_not_comm, not_lt, nat.le_zero_iff]

lemma ham_dist_eq_zero_iff_forall_eq (x y : ham Œ≤) : ham_dist x y = 0 ‚Üî ‚àÄ i, x i = y i :=
by rw [ham_dist_eq_zero, function.funext_iff]

lemma ham_dist_ne_zero_iff_exists_ne (x y : ham Œ≤) : ham_dist x y ‚â† 0 ‚Üî ‚àÉ i, x i ‚â† y i :=
by rw [ham_dist_ne_zero, function.ne_iff]

section has_zero

variable [Œ† i, has_zero (Œ≤ i)]

def ham_wt (x : ham Œ≤) : ‚Ñï := ham_dist x 0

lemma ham_wt_smul_le [has_zero Œ±] [Œ† i, smul_with_zero Œ± (Œ≤ i)] (k : Œ±) (x : ham Œ≤) :
ham_wt (k ‚Ä¢ x) ‚â§ ham_wt x :=
by rw [ham_wt, ‚Üê smul_zero' (ham Œ≤) k]; exact ham_dist_smul_le _ _ _

lemma ham_wt_smul [has_zero Œ±] [Œ† i, smul_with_zero Œ± (Œ≤ i)] {k : Œ±}
(hk : ‚àÄ i, is_smul_regular (Œ≤ i) k) (x : ham Œ≤) : ham_wt x = ham_wt (k ‚Ä¢ x) :=
by simp_rw ham_wt; nth_rewrite 1 ‚Üê smul_zero' (ham Œ≤) k; exact ham_dist_smul hk _ _

lemma ham_wt_eq (x : ham Œ≤) : ham_wt x = card {i // x i ‚â† 0} := rfl

lemma ham_wt_eq_zero (x : ham Œ≤) : ham_wt x = 0 ‚Üî x = 0 := ham_dist_eq_zero _ _

lemma ham_wt_zero : ham_wt (0 : ham Œ≤) = 0 := ham_dist_self _

lemma zero_of_ham_wt_eq_zero (x : ham Œ≤) : ham_wt x = 0 ‚Üí x = 0 := eq_of_ham_dist_eq_zero _ _

lemma ham_wt_ne_zero (x : ham Œ≤) : ham_wt x ‚â† 0 ‚Üî x ‚â† 0 := ham_dist_ne_zero _ _

lemma ham_wt_pos (x : ham Œ≤) : 0 < ham_wt x ‚Üî x ‚â† 0 := ham_dist_pos _ _

lemma ham_wt_zero_iff_forall_zero (x : ham Œ≤) : ham_wt x = 0 ‚Üî ‚àÄ i, x i = 0 :=
ham_dist_eq_zero_iff_forall_eq _ _

lemma ham_wt_pos_iff_exists_nz (x : ham Œ≤) : ham_wt x ‚â† 0 ‚Üî ‚àÉ i, x i ‚â† 0 :=
ham_dist_ne_zero_iff_exists_ne _ _

end has_zero

lemma ham_dist_eq_ham_wt_sub [Œ† i, add_group (Œ≤ i)] (x y : ham Œ≤) : ham_dist x y = ham_wt (x - y) :=
by simp_rw [ham_dist_eq, ham_wt_eq, pi.sub_apply, sub_ne_zero]

instance : has_dist (ham Œ≤) := ‚ü®Œª x y, ham_dist x y‚ü©

@[simp, push_cast] lemma dist_eq_ham_dist (x y : ham Œ≤) : dist x y = ham_dist x y := rfl

instance : pseudo_metric_space (ham Œ≤) :=
{ dist_self           := by push_cast; exact_mod_cast ham_dist_self,
  dist_comm           := by push_cast; exact_mod_cast ham_dist_comm,
  dist_triangle       := by push_cast; exact_mod_cast ham_dist_triangle,
  ..ham.has_dist }

instance : metric_space (ham Œ≤) :=
{ eq_of_dist_eq_zero  := by push_cast; exact_mod_cast eq_of_ham_dist_eq_zero,
  ..ham.pseudo_metric_space }

instance [Œ† i, has_zero (Œ≤ i)] : has_norm (ham Œ≤) := ‚ü®Œª x, ham_wt x‚ü©

@[simp, push_cast] lemma norm_eq_ham_wt [Œ† i, has_zero (Œ≤ i)] (x : ham Œ≤) : ‚à•x‚à• = ham_wt x := rfl

instance [Œ† i, add_comm_group (Œ≤ i)] : semi_normed_group (ham Œ≤) :=
{ dist_eq := by push_cast; exact_mod_cast ham_dist_eq_ham_wt_sub, ..pi.add_comm_group }

instance [Œ† i, add_comm_group (Œ≤ i)] : normed_group (ham Œ≤) := { ..ham.semi_normed_group }

/-
Want something like this:
instance [Œ† i, add_comm_group (Œ≤ i)] {Œ± : Type*} [normed_field Œ±] [Œ† i, module Œ± (Œ≤ i)] : normed_space Œ± (ham Œ≤) := sorry

But this isn't true. There is no existing structure that captures properties like ham_wt_smul_le.

This is unfortunate - because the module structure ought to combine with the metric structure!
-/

end decidable_eq

end hamming
